/*** ...* @author Jeff Fulton* @version 0.1*/package  {		import fl.motion.MatrixTransformer;	import flash.display.Bitmap;	import flash.display.Sprite;	import flash.geom.*;	import flash.display.BitmapData;	import flash.utils.getDefinitionByName;	import flash.events.*;	import flash.display.Shape;	import flash.filters.GlowFilter;			import GameLoop;	import Player;	import Tile;	import EnemyGenerator;	import EnemyType;	import Enemy;	import GameDataXML;	import TileSheet;	import iLevelData;	import LevelEnemyType;	import ScorePanel;	import LevelInScreen;	import GameOverScreen;	import GetReadyScreen;	import PowerUpType;	import ExplodeType;	import GameUtils;	import PausedScreen;	import InPlayMessage;	import GameMessageManager;				public class GamePlay extends EventDispatcher{			//states		public static const STATE_INIT_NEW_GAME:int=0;		public static const STATE_LOAD_LEVEL_DATA:int=1;		public static const STATE_SET_UP_LEVEL:int=2;		public static const STATE_LEVEL_IN:int=3;		public static const STATE_LEVEL_PLAY:int=4;		public static const STATE_LEVEL_OUT:int=5;		public static const STATE_GAME_WON:int=7;		public static const STATE_LEVEL_GAME_OVER:int=6;				//game play states		public static const STATE_PLAY_GETREADY:int=0;		public static const STATE_PLAY_PLAYERSTART:int=1;		public static const STATE_PLAY_GAMERUN:int=2;		public static const STATE_PLAY_PLAYERDIE:int=3;		public static const STATE_PLAY_PLAYEROUT=4;		public static const STATE_PLAY_DEBUG:int=99;		public static const STATE_PLAY_PAUSED:int=5;				//states shared between player and enemy objects				public static const MOVE_STATE_UP:String="up";		public static const MOVE_STATE_DOWN:String="down";		public static const MOVE_STATE_LEFT:String="left";		public static const MOVE_STATE_RIGHT:String="right";		public static const MOVE_STATE_STOP:String="stop";		public static const MOVE_STATE_ERASE:String="erase";		public static const MOVE_STATE_DEATH:String="death";		public static const MOVE_STATE_FADEOUT:String="fadeout";		public static const MOVE_STATE_TRANSPORT:String="transport";		public static const MOVE_STATE_LEVELOUT:String="levelout";		public static const ANIMATE_UPTOLEFT:String="animate_uptoleft";		public static const ANIMATE_UPTORIGHT:String="animate_uptoright";		public static const ANIMATE_UPTODOWN:String="animate_uptodown";		public static const ANIMATE_DOWNTOLEFT:String="animate_downtoleft";		public static const ANIMATE_DOWNTORIGHT:String="animate_downtoright";		public static const ANIMATE_DOWNTOUP:String="animate_downtoup";		public static const ANIMATE_LEFTTOUP:String="animate_lefttoup";		public static const ANIMATE_LEFTTODOWN:String="animate_lefttodown";		public static const ANIMATE_LEFTTORIGHT:String="animate_lefttoright";		public static const ANIMATE_RIGHTTOUP:String="animate_righttoup";		public static const ANIMATE_RIGHTTODOWN:String="animate_righttodown";		public static const ANIMATE_RIGHTTOLEFT:String="animate_righttoleft";				public static const AI_STATE_CHASE:String="chase";		public static const AI_STATE_FLEE:String="flee";		public static const AI_FILTER_FLEE:String="filter_flee";				//for iteration access		public var aMoveState=[MOVE_STATE_UP,MOVE_STATE_DOWN,MOVE_STATE_LEFT,MOVE_STATE_RIGHT,MOVE_STATE_STOP, MOVE_STATE_ERASE];				//INIT_NEW_GAME				//player		public var player:Player;		//public var lookAhead:Sprite;				//game control		public var gameLoop:GameLoop;		public var currentState:int;		public var gameDataXML:GameDataXML;		public var gameXML:XML;		//play control		public var currentPlayState:int;						//tile map data		public var aTileMap:Array;		public var mapRows:int;		public var mapCols:int;		public var tileSheetWidth:int;		public var tileSheetHeight:int;		public var tileSize:int;		public var screenWidth:int;		public var screenHeight:int;				public var tilesPerRow:int;				//game data		var level:int;		var dotTotalCount:int=0;		var dotEatenCount:int=0;		var dotScore:int;				//tilesheet		var tileSheet:TileSheet;		var tilesheetBitmapData:BitmapData;		var aTilesheetData:Array;				//level in		var levelInScreen:LevelInScreen;				//level in		var levelOutScreen:LevelOutScreen;				//get ready		var getReadyScreen:GetReadyScreen;				//gameOver		var gameOverScreen:GameOverScreen;				//level data		var levelData:XML;		var level1DataXML:Level1DataXML;		var level2DataXML:Level2DataXML;		var level3DataXML:Level3DataXML;				//animated times		var aAnimatedTile:Array;				//enemy generators		var aEnemyGenerator:Array;				//transports and receivers		var aTransport:Array;		var aReceiver:Array;				//background 		var backgroundBitmapData:BitmapData;		var backgroundTile:int; // holds 0-255 num of background tile in tileSheet				//gamescreen		var gameScreenBitmap:Bitmap;		var gameScreenBitmapData:BitmapData;		var gameScreenBitmapDataDisplay:BitmapData; // the final display buffer for double buffering				//copying tiles to screen		var tileRect:Rectangle;		var tilePoint:Point;				//powerups		var oPowerUpType:Object;				//scorepanel		var scorePanel:ScorePanel;				//bonus		var timeBonus:int;		var extraManAmount:int;		var enemyToEatForBonusXPlus:int;		var attackBonusPerKill:int;		var killBonusMultiplier:int=10; // each time you kill an enemy and do not die, this increases the attackbonusperkill		var killBonusCount:int=0;				//collisions		var dotEatThreshold:int=16; // the amount +/- the center of the dot tile to register a hit		var erasertile:int;		var enemyHitThreshold:int=10;		var hitTransThreshold:int=10;				//explosions		var oExplodeType:Object;		var aExplode:Array;				//InPlayMessages		var aMessage:Array;				//paused		var previousStateBeforePause:int;		var pausedScreen:PausedScreen;				//game message box		var gameMessageManager:GameMessageManager;				//transports and receivers		var oReceiverType:Object;								//debug		var debugCtr:int=0;				//framerate		var levelFrameRate:int=40;				//*** for optimizations ****				//basic counters		var ctr1:int;		var ctr2:int;				//collision detection variables for optimization		var hitx:Number;		var hity:Number;		var rFound:Boolean;		var invincbibleTimeToAdd:int;		var attackTimeToAdd:int;		var accTimeToAdd:int;		var destY:int;		var destX:int;		var thisTile:Tile;		var enemyLength:int;		var enemyCounter:int;		var sheetTile:BasicGameTile;		var tempTile:Tile;		var randReceiver:int;								//buffer var optimizations		var bufferMatrix:Matrix=new Matrix();		var screenRectangle:Rectangle;		var screenTopPoint=new Point(0,0);				//explode and text effects var optimizations		var explodeLength:int;		var tempExplode:Explode;		var eCtr:int; 		var messageLength:int;		var eCtr2:int; 				//in play messages		var message:InPlayMessage;				//enemy		var tempEnemy:Enemy;		var attackBonus:int;				//tile render		var tempTileRender:Tile;		var rowCtr:int;		var colCtr:int;				//difficulty		//speed adjust for level		public static const NORMAL:int=1;		public static const HARD:int=2;		public static const INSANE:int=3;		var levelspeedadjust:Number=NORMAL;		var numLevels:int;							//*** end optimizations				//enemy		//enemy vars		private var maxEnemy:int=0; // will be sum ofof num of each enemy type in a level		private var aEnemy:Array;		private var aEnemyType:Array; //holds array of dynamic enemy types loaded in via xml						//gameplay events 		public static const RENDER:String = "render";		public static const UPDATE:String = "update";		public static const CHECK_WALL_COLLISIONS ="checkwallcollisions";		public static const LEVELINUPDATE:String = "levelinupdate";		public static const GETREADYUPDATE:String = "getreadyupdate";		//player		public static const PLAYERDIE:String = "playerdie";		public static const PLAYERDEATHSTARTED:String = "playerdeathstarted";		public static const PLAYERDEATHUPDATE:String ="playerdeathupdate";		public static const PLAYERDEATHCOMPLETE:String ="playerdeathcomplete";		public static const PLAYERSTART:String="playerstart";		public static const PLAYEREATDOT:String="playereatdot";		public static const PLAYEREATPOWERUP:String="playereatpowerup";		public static const PLAYEREATENEMY:String="playereatenemy";		public static const PLAYEROUTSTARTED:String="playeroutstarted";					//timers		public static const ACCTIMERSTART:String="acctimerstart";		public static const ACCTIMEREND:String="acctimerend";		public static const ACCTIMERABOUTTOEND:String="acctimerabouttoend";				public static const ENEMYAIFLEE:String="enemyaiflee";		public static const POWERUPATTACKSTART:String="powerupattackstart";		public static const POWERUPATTACKEND:String="powerupattackend";		public static const POWERUPATTACKABOUTOEND:String="powerupattackabouttoend";				public static const INVTIMERSTART:String="invtimerstart";		public static const INVTIMEREND:String="invtimerend";		public static const INVTIMERABOUTTOEND:String="invtimerabouttoend";				//kill all enemy power up		public static const POWERUPKILLALL:String="powerupkillall";				//princess		public static const POWERUPPRINCESS:String="powerupprincess";		public static const POWERUPPRINCESSPLAYSOUND:String="powerupprincessplaysound";		public var princessWaitStarted:Boolean=false;		public var princessWait:Number=30;		public var princessCount:Number=0;				//tiles		public static const KEYEATEN:String="keyeaten";				//leveloutscreen		public static const LEVELOUTUPDATE:String = "leveloutupdate";		public static const LEVELOUTCOUNTTIMEBONUS:String = "leveloutupcounttimebonus";			//game over screen		public static const GAMEOVERUPDATE:String = "gameoverupdate";				//paused started 		public static const PAUSEDSTARTED:String = "pausestarted";				//transport		public static const TRANSPORTSTART:String = "transportstarted";				//bomusx		public static const BONUSXUPDATE:String = "bonusXUpdate";		public static const INCREMENTBONUSX:String = "incrementbonusx";				//quit		public static const GAMEQUIT:String = "gamequit";				public function GamePlay(gameLoopval:GameLoop){			trace("game play instantiated");			gameLoop=gameLoopval;									currentState=STATE_INIT_NEW_GAME;			trace("new game init");		}			public function gettimeBonus():int {			return timeBonus;					}				public function getextraManAmount():int {			return extraManAmount;		}				public function getenemyToEatForBonusXPlus():int {			return (enemyToEatForBonusXPlus);		}				public function getPlayerbonusX():int {			return (player.bonusX);		}				public function getPlayerattackBonus():int {			return (player.attackBonus);		}				public function getaMoveState():Array {			return aMoveState;		}			public function getlevel():int {			return level;		}			public function getPlayerCurrentCol():int {			//used for enemy access			return player.tileCol;		}				public function getPlayerCurrentRow():int {			//used for enemy access			return player.tileRow;		}			public function gettilesheetBitmapData():BitmapData {			return tilesheetBitmapData;		}			public function getgameScreenBitmapData():BitmapData {			return gameScreenBitmapData;		}				public function gettilesPerRow():int {			return tilesPerRow;		}				public function getgameXML():XML {			return gameXML;		}				public function getaTileMap():Array{			return aTileMap;		}				public function geterasertile():int {			return erasertile;		}				public function getaTilesheetData():Array {			return aTilesheetData;		}						public function getlevelspeedadjust():Number {			return levelspeedadjust;		}				public function getaLevelPassword():Array {			return gameLoop.getaLevelPassword();		}				public function runGame() {			//called each frame by the gameLoop			//trace("run game");			switch (currentState) {				case STATE_INIT_NEW_GAME:					initNewGame();					break;				case STATE_LOAD_LEVEL_DATA:				//trace("case load level data");3									loadLevelData();					break;				case STATE_SET_UP_LEVEL:					setUpLevel();					break;				case STATE_LEVEL_IN:					levelIn();					break;				case STATE_LEVEL_PLAY:					levelPlay()					break;				case STATE_LEVEL_OUT:					levelOut();					break;				case STATE_LEVEL_GAME_OVER:					gameOver();					break;				case STATE_GAME_WON:					gameWon();					break;				}				}				public function initNewGame() {			trace ("init new game");			//create objects needed for new game.			//1. get game xml data						gameDataXML=new GameDataXML();			gameXML=gameDataXML.getXML();			numLevels=gameXML.numlevels;			tileSize=gameXML.tilesize;			screenWidth=gameXML.screenwidth;			screenHeight=gameXML.screenheight;			screenRectangle=new Rectangle(0,0,screenWidth,screenHeight);			tileSheetWidth=gameXML.tilesheetwidth;			tileSheetHeight=gameXML.tilesheetheight;			mapRows=int(screenHeight/tileSize);			mapCols=int(screenWidth/tileSize);			tilesPerRow=int(tileSheetWidth/tileSize);			if (gameLoop.getbLevelOverride()) {				level=gameLoop.getiLevelOverride();				levelspeedadjust=gameLoop.getlast_levelspeedadjust();				trace("levelspeedadjust=" + levelspeedadjust);				trace("overriding level to : " + gameLoop.getiLevelOverride());			}else{				level=gameXML.level;			}			dotScore=gameXML.dotscore;			erasertile=gameXML.erasertile;			//trace("eraserTile=" + erasertile);			//tile sheet			tileSheet=new TileSheet(tileSheetWidth,tileSheetHeight, tileSize);			tilesheetBitmapData=tileSheet.getbitmapSheet();			aTilesheetData=tileSheet.getaTileData();			//pre init tileRect and tilePoint			tileRect=new Rectangle(0,0,tileSize,tileSize);			tilePoint=new Point(0,0);									//player						player=new Player(this);			player.tileSize=tileSize;			player.setblitRectangle();			player.mapRows=mapRows;			player.mapCols=mapCols;			player.acceleration=gameXML.playeracceleration;			player.animate=true;			player.createMoveStates();			player.score=gameXML.score;			player.lives=gameXML.lives;			//create object types from XML			createEnemyTypes();			createPowerUpTypes();			createExplodeTypes();			trace("about to create paused screen");			pausedScreen=new PausedScreen(this);			trace("about to set up scorePanel in gameplay");			scorePanel=gameLoop.gameLoopScorePanel;			scorePanel.setGamePlay(this);			scorePanel.addGamePlayEventListeners();			scorePanel.updateScore(player.score);			trace("about to add player score panel listeners");			//gameLoop.addChild(scorePanel);			player.addScorePanelListeners();			//prepare in game screens			//level			gameOverScreen=new GameOverScreen(this);			levelInScreen=new LevelInScreen(this);			levelOutScreen=new LevelOutScreen(this);			scorePanel.updateLevel(level);			scorePanel.updateLives(player.lives);			trace("init game message manager");			gameMessageManager=new GameMessageManager(this);			//get ready			trace("gameMessageManagerInit complete");			getReadyScreen=new GetReadyScreen(this);						//set current states			currentState=STATE_LOAD_LEVEL_DATA;			currentPlayState=STATE_PLAY_GETREADY;						//add key listener			gameLoop.stage.addEventListener(KeyboardEvent.KEY_DOWN,keyDownListener,false,0,true);						//sound manager init						gameLoop.soundManager.setgamePlay(this);			gameLoop.soundManager.initListeners();				}				public function levelIn() {			if (!levelInScreen.getstarted()) {				levelInScreen.start();				levelInScreen.addEventListener(LevelInScreen.COMPLETE, levelInCompleteListener,false,0,true);			}			dispatchEvent(new Event(LEVELINUPDATE));				if (gameScreenBitmap.y <0) {				gameScreenBitmap.y+=10;			}					}				public function levelInCompleteListener(e:Event) {			if (gameScreenBitmap.y !=0) {				gameScreenBitmap.y=0;			}			levelInScreen.removeEventListener(LevelInScreen.COMPLETE, levelInCompleteListener);			currentState=STATE_LEVEL_PLAY;					}				public function levelPlay() {			//state machine for play			switch (currentPlayState) {				case STATE_PLAY_GETREADY:					playGetReady();					//trace("case playGetready");					break;				case STATE_PLAY_PLAYERSTART:					//////trace("case playPlayerStart");					playPlayerStart();					break;				case STATE_PLAY_GAMERUN:					//////trace("case playGameRun");					playGameRun();					break;				case STATE_PLAY_PLAYERDIE:					//////trace("case playPlayerDie");					playPlayerDie();					break;				case STATE_PLAY_PLAYEROUT:					//////trace("case layPlayerOut()");					playPlayerOut();					break;				case STATE_PLAY_PAUSED:					playPaused();					break;				case STATE_PLAY_DEBUG:					//trace("case Debug");					break;			}			}						public function loadLevelData() {			aAnimatedTile = [];			aEnemyGenerator = [];			aTileMap=[];			aTransport=[];			aReceiver=[];			oReceiverType={};			//load level data with special classRef method			var levelString:String="Level"+level+"DataXML";			//trace("levelString=" + levelString);			var classRef:Class = getDefinitionByName(levelString) as Class			trace(" Level 1");			var levelDataClass:* = new classRef();			trace("Level 2")			levelData=levelDataClass.getXML();			trace("Level 3")			for (var rowCtr=0;rowCtr<mapRows;rowCtr++) {				trace("row=" + rowCtr);				var tempArray:Array=new Array();								for (var colCtr=0;colCtr<mapCols;colCtr++) {					trace("col=" + colCtr);					//**** attributes ****					//w=walkable					//c=collectible					//p=powerup					//a=animate					//d=door					//k=key					//aList="," separated  list of other tiles in animation loop					//eg=enemy generator					var tileNum:int=levelData.tilerow[rowCtr].tilecol[colCtr];					var sheetTile=aTilesheetData[tileNum];					var tempTile:Tile=new Tile(tileNum,this);					tempTile.aTileBitmapData=sheetTile.aTileBitmapData;					tempTile.isWalkable=sheetTile.isWalkable;					tempTile.isCollectible=sheetTile.isCollectible;					if (tempTile.isCollectible) {						dotTotalCount++;					}					tempTile.isKey=sheetTile.isKey;										if (tempTile.isKey) {						//levelInScreen.oSpecialRow["key"]=true;					}					tempTile.isDoor=sheetTile.isDoor;					if (tempTile.isDoor) {						tempTile.setkeyEatenListener();						//levelInScreen.oSpecialRow["door"]=true;					}					tempTile.isPowerUp=sheetTile.isPowerUp;					tempTile.powerUpType=sheetTile.powerUpType;										if (tempTile.isPowerUp) {						tempTile.poweruptitle=oPowerUpType[tempTile.powerUpType].title;						//if (tempTile.poweruptitle == "attack1") levelInScreen.oPowerUpRow["attack1"]=true;						//if (tempTile.poweruptitle == "attack2") levelInScreen.oPowerUpRow["attack2"]=true;						//if (tempTile.poweruptitle == "attack3") levelInScreen.oPowerUpRow["attack3"]=true;						//if (tempTile.poweruptitle == "attack4") levelInScreen.oPowerUpRow["attack4"]=true;						//if (tempTile.poweruptitle == "freeze") levelInScreen.oPowerUpRow["freeze"]=true;						//if (tempTile.poweruptitle == "protect") {							//levelInScreen.oPowerUpRow["protect"]=true;							//trace("*** protect tile found");						//}						//if (tempTile.poweruptitle == "kill") levelInScreen.oPowerUpRow["kill"]=true;						//if (tempTile.poweruptitle == "bonusx") levelInScreen.oPowerUpRow["bonusx"]=true;						//if (tempTile.poweruptitle == "princess") levelInScreen.oPowerUpRow["princess"]=true;											}										tempTile.animate=sheetTile.animate;					if (tempTile.animate) {						tempTile.addRenderListener();					}					tempTile.tileSize=sheetTile.tileSize;					//tempTile.setblitRectangle();					tempTile.mapRow=rowCtr;					tempTile.mapCol=colCtr;					tempTile.destX=tempTile.mapCol*tempTile.tileSize;					tempTile.destY=tempTile.mapRow*tempTile.tileSize;					tempTile.animationFrameDelay=sheetTile.animationFrameDelay					if (tempTile.animate) {						aAnimatedTile.push(tempTile);					}										tempTile.isEnemyGenerator=sheetTile.isEnemyGenerator;					if (tempTile.isEnemyGenerator) {						aEnemyGenerator.push(new EnemyGenerator(rowCtr,colCtr,this));						}					if (sheetTile.isTransport) {						tempTile.isTransport=sheetTile.isTransport;						tempTile.transportID=sheetTile.transportID;						aTransport.push(tempTile);						//levelInScreen.oSpecialRow["transport"+tempTile.transportID]=true;					}					/*					if (sheetTile.isReceiver) {						tempTile.isReceiver=sheetTile.isReceiver;						tempTile.transportID=sheetTile.transportID;												if (oReceiverType[tempTile.transportID] == null) {							var tempReceiverType=new ReceiverType(tempTile.transportID);							tempReceiverType.count++;							oReceiverType[tempTile.transportID]=tempReceiverType;						}else{							oReceiverType[tempTile.transportID].count++;						}																														aReceiver.push(tempTile);					}					*/					tempArray.push(tempTile);				}				aTileMap.push(tempArray);			}												currentState=STATE_SET_UP_LEVEL;			}					public function setUpLevel() {			//draw level on screen			backgroundBitmapData=new BitmapData(480,480,false,0xFFFFFF);			gameScreenBitmapData=new BitmapData(480,480,false,0xFFFFFF);			//gameScreenBitmapDataDisplay=new BitmapData(480,480,false,0xFFFFFF);			//bonus data			timeBonus=int(levelData.timebonus);			extraManAmount=int(levelData.extramanamount);			enemyToEatForBonusXPlus=int(levelData.enemytoeatforbonusxplus);			attackBonusPerKill=int(levelData.attackbonusperkill);			//levelspeedadjust=Number(levelData.levelspeedadjust);			//frameRate			levelFrameRate=levelData.framerate;			gameLoop.stage.frameRate=levelFrameRate;						backgroundTile=levelData.backgroundtile;			copyBackgroundTileToBackground();			copyBackgroundToScreen();			copyTilemapToScreen();			copyBufferToDisplay();			//gameScreenBitmap=new Bitmap(gameScreenBitmapDataDisplay);			gameScreenBitmap=new Bitmap(gameScreenBitmapData);			gameScreenBitmap.y=-screenHeight;			gameLoop.addChild(gameScreenBitmap);			//////trace("backgroundTile=" + backgroundTile);						//setup player for this level			player.aSpriteBitmapData=player.getBitmapState(MOVE_STATE_RIGHT);			//////trace("set up first move state");			player.spriteBitmapDataIndex=0;			//////trace("set spriteBitmapDataIndex=0");			player.animationFrameDelay=5;			//////trace("set player.animationFrameDelay=10");			//player.initPosition((playerStartCol*tileSize)+.5*tileSize,(playerStartRow*tileSize)+.5*tileSize)			player.resetLevelCounters();			player.bonusTimeLimit=levelData.bonustimelimit;			scorePanel.bonusTimerSet(player.bonusTimeLimit * 1000);			//create a debugging look-ahead sprite			//lookAhead=new Sprite();			//var tempShape:Shape=new Shape();			//tempShape.graphics.beginFill(0xff0000,1);			//tempShape.graphics.lineStyle(2,0x000000);			//tempShape.graphics.lineTo(5,0);			//tempShape.graphics.lineTo(5,5);			//tempShape.graphics.lineTo(0,5);			//tempShape.graphics.lineTo(0,0);			//tempShape.graphics.endFill();			//tempShape.x=-.5*tempShape.width;			//tempShape.y=-.5*tempShape.height;			//lookAhead.addChild(tempShape);						//gameLoop.addChild(lookAhead);			//gamePlay state control			currentState=STATE_LEVEL_IN;			//put current level on scorePanel			scorePanel.updateLevel(level);						aExplode=[];			aMessage=[];			createEnemyForLevel(); 		}			function createEnemyTypes():void {			aEnemyType=[]; //holds array of dynamic enemy types loaded in via xml			var tempEnemyType:EnemyType;			var speed:Number;			var intelligence:Number;			var id:String;			var score:int;			var sourceX:int;			var sourceY:int;			var tileNum:int;			var title:String;						for each (var child:XML in gameXML.enemy) {				trace ("enemy");				speed=child.speed;				id=child.id;				intelligence=child.intelligence;				score=child.score;				title=child.Title;				trace ("enemy2");				var rightTempArray:Array=[];				var leftTempArray:Array=[];				var upTempArray:Array=[];				var downTempArray:Array=[];				var eraseTempArray:Array=[];				var fleefilterTempArray:Array=[];				trace ("enemy3");								tempEnemyType=new EnemyType(id,speed,intelligence, score);				//trace ("enemy3.1");				tempEnemyType.title=title;				//trace ("enemy3.2");				var eraseBitmapData:BitmapData=aTilesheetData[erasertile].aTileBitmapData[0];				//trace ("enemy3.3");				eraseTempArray.push(eraseBitmapData);				//trace ("enemy3.4");				tempEnemyType.addBitmapState(MOVE_STATE_ERASE,eraseTempArray);				//left				//trace ("enemy3.5");				for each (var child2:XML in child.lefttile) {					//trace("left child2=" + child2);					tileNum=int(child2);					//trace("left tile:" + tileNum);					var leftBitmapData:BitmapData=aTilesheetData[tileNum].aTileBitmapData[0];					leftTempArray.push(leftBitmapData);				}				//trace ("enemy3.6");				tempEnemyType.addBitmapState(MOVE_STATE_LEFT,leftTempArray);								//trace ("enemy4");								//right				for each (child2 in child.righttile) {					////////trace("right child2=" + child2);					tileNum=int(child2);					////////trace("left tile:" + tileNum);					var rightBitmapData:BitmapData=aTilesheetData[tileNum].aTileBitmapData[0];					rightTempArray.push(rightBitmapData);				}				tempEnemyType.addBitmapState(MOVE_STATE_RIGHT,rightTempArray);				//////trace("right array length=" + tempEnemyType.getBitmapState(MOVE_STATE_RIGHT).length);								//trace ("enemy5");								//up				for each (child2 in child.uptile) {					////////trace("up child2=" + child2);					tileNum=int(child2);					////////trace("left tile:" + tileNum);					var upBitmapData:BitmapData=aTilesheetData[tileNum].aTileBitmapData[0];					upTempArray.push(upBitmapData);				}				tempEnemyType.addBitmapState(MOVE_STATE_UP,upTempArray);				//////trace("sonw with uptile")								//trace ("enemy6");							//down				for each (child2 in child.downtile) {					////////trace("down child2=" + child2);					tileNum=int(child2);					////////trace("left tile:" + tileNum);					var downBitmapData:BitmapData=aTilesheetData[tileNum].aTileBitmapData[0];					downTempArray.push(downBitmapData);				}				tempEnemyType.addBitmapState(MOVE_STATE_DOWN,downTempArray);				//trace ("enemy7");								//flee				for each (child2 in child.fleefilter) {					////////trace("down child2=" + child2);					tileNum=int(child2);					////////trace("left tile:" + tileNum);					var fleefilterBitmapData:BitmapData=aTilesheetData[tileNum].aTileBitmapData[0];					fleefilterTempArray.push(fleefilterBitmapData);				}				tempEnemyType.addBitmapState(AI_FILTER_FLEE,fleefilterTempArray);												//trace ("enemy8");															aEnemyType.push(tempEnemyType);																//trace ("enemy9");																		}					//////trace("done creating enemy types");						}			function createEnemyForLevel():void {			//reset enemy vars per level			aEnemy=[];						//////trace ("creating enemy types for this level");			for each (var child:XML in levelData.enemytype) {				//////trace("child.enemytype=" + child);				var numToCreate:int=(child.@num);				var enemyTypeToCreate:String=child;				for (var etctr:int=0;etctr<numToCreate;etctr++) {					//////trace("1");					var randEG:int = int(Math.random()*aEnemyGenerator.length);					var tempGenerator:EnemyGenerator=aEnemyGenerator[randEG];					var startX:int = (tempGenerator.col * tileSize);					var startY:int = (tempGenerator.row * tileSize);					var tempEnemy:Enemy=new Enemy(startX,startY,this);					//////trace("2")										for (var etNum=0;etNum< aEnemyType.length;etNum++) {//need to find correct enemyType here						//////trace("3")						//////trace("enemyTypeToCreate=" + enemyTypeToCreate);						//////trace("aEnemyType[etNum].id=" + aEnemyType[etNum].id);												if (enemyTypeToCreate == aEnemyType[etNum].id) {							var tempEnemyType:EnemyType=aEnemyType[etNum];							//levelInScreen.oEnemyRow[tempEnemyType.title]=true;							trace("tempEnemyType.title = " + tempEnemyType.title);							//////trace("4")						}					}					tempEnemy.bitmapStateObject=tempEnemyType.bitmapStateObject;					//////trace("right array length=" + tempEnemy.getBitmapState(MOVE_STATE_RIGHT).length);					tempEnemy.aSpriteBitmapData=tempEnemy.getBitmapState(MOVE_STATE_RIGHT);					tempEnemy.spriteBitmapDataIndex=1;					tempEnemy.animationFrameDelay=10;					//tempEnemy.initBitmap();					//////trace("enemy aSpriteBitmapData.length=" + tempEnemy.aSpriteBitmapData.length);					tempEnemy.acceleration=tempEnemyType.speed;					//tempEnemy.acceleration=0;					tempEnemy.intelligence=tempEnemyType.intelligence;					tempEnemy.tileRow=tempGenerator.row;					tempEnemy.tileCol=tempGenerator.col;					tempEnemy.score=tempEnemyType.score;					tempEnemy.setlastTile();					tempEnemy.animate=false;					tempEnemy.tileSize=tileSize;					tempEnemy.setblitRectangle();					tempEnemy.mapRows=mapRows;					tempEnemy.mapCols=mapCols;					//tempEnemy.setBitmapAtOrigin();					tempEnemy.rendervelocity=true;					tempEnemy.restartFrameDelay=levelData.enemyrestartFrameDelay;					tempEnemy.frameDelayBeforeStart=levelData..enemystartFrameDelay;										//gameLoop.addChild(tempEnemy);					aEnemy.push(tempEnemy);					//////trace("pushed enemy");				}				//////trace("aEnemy.length=" + aEnemy.length);			}															}				public function copyBackgroundTileToBackground() {			for (var rowCtr:int=0;rowCtr<mapRows;rowCtr++) {								for (var colCtr:int=0;colCtr<mapCols;colCtr++) {					var tempTile2:BasicGameTile=aTilesheetData[backgroundTile];					var tileBitmapData2:BitmapData=tempTile2.getCurrentBitmapData();					var destY:int=rowCtr*tileSize;					var destX:int=colCtr*tileSize;					backgroundBitmapData.copyPixels(tileBitmapData2,new Rectangle(0,0,tileSize,tileSize), new Point(destX,destY));				}			}					}			public function copyTilemapToScreen(){			/*			gameLoop.graphics.clear();			gameLoop.graphics.beginBitmapFill(gameScreenBitmapData);			gameLoop.graphics.drawRect(0, 0, screenWidth, screenHeight);			gameLoop.graphics.endFill();			*/												for (rowCtr=0;rowCtr<mapRows;rowCtr++) {								for (colCtr=0;colCtr<mapCols;colCtr++) {					var tempTileRender:Tile=aTileMap[rowCtr][colCtr];					tempTileRender.render();					//var tileBitmapData2:BitmapData=tempTile2.getCurrentBitmapData();					//var destY:int=rowCtr*tileSize;					//var destX:int=colCtr*tileSize;					tilePoint.x=colCtr*tileSize;					tilePoint.y=rowCtr*tileSize					gameScreenBitmapData.copyPixels(tempTileRender.getCurrentBitmapData(),tileRect,tilePoint);				}			}		}			public function copyBackgroundToScreen() {						gameScreenBitmapData.copyPixels(backgroundBitmapData,screenRectangle, screenTopPoint);		}									function createExplodeTypes():void {			trace("creating explode types");			oExplodeType={}; 									for each (var child:XML in gameXML.explosion) {				var tempExplodeType:ExplodeType;				var tempBitmapArray:Array=[];				for each (var child2:XML in child.tile) {					var tileNum:int=int(child2);					var tileBitmapData:BitmapData=aTilesheetData[tileNum].aTileBitmapData[0];					tempBitmapArray.push(tileBitmapData);					trace("explodeTileNum=" + tileNum);				}				tempExplodeType=new ExplodeType(tempBitmapArray,child.id);				oExplodeType[child.id]=tempExplodeType;			}					trace("oExplodeType.toString()=" + oExplodeType.toString());					}						function createPowerUpTypes():void {			oPowerUpType={}; //holds array of dynamic enemy types loaded in via xml									for each (var child:XML in gameXML.powerup) {				////////trace ("enemy");				var tempPowerUpType:PowerUpType;				tempPowerUpType=new PowerUpType(child.type);				//trace("tempPowerUpType.id=" + child.type);				tempPowerUpType.playerAccAdjust=int(child.playeraccadjust);				tempPowerUpType.playerAccTimeAdd=int(child.playeracctimeadd);				tempPowerUpType.playerInvincibleAdjust=GameUtils.stringToBoolean(child.playerinvincibleadjust);				//trace("tempPowerUpType.playerInvincibleAdjust=" + tempPowerUpType.playerInvincibleAdjust);				tempPowerUpType.playerInvincibleTimeAdd=int(child.playerinvincibletimeadd);				tempPowerUpType.playerEatEnemyAdjust=GameUtils.stringToBoolean(child.playereatenemyadjust);				tempPowerUpType.playerEatEnemyTimeAdd=int(child.playereatenemytimeadd);				tempPowerUpType.playerScoreAdjust=int(child.playerscoreadjust);				tempPowerUpType.playerBonusAdjust=int(child.playerbonusadjust);				tempPowerUpType.playerBonusTimeAdjust=int(child.playerbonustimeadjust);				tempPowerUpType.playerKillAllEnemyAdjust=GameUtils.stringToBoolean(child.playerkillallenemyadjust);				tempPowerUpType.playerBonusXAdjust=int(child.playerbonusxadjust);				tempPowerUpType.title=child.Title;				tempPowerUpType.type=int(child.type);								//power up types are accessed by the type as an index of any array				oPowerUpType[tempPowerUpType.type]=tempPowerUpType;								trace("tempPowerUpType.type=" + tempPowerUpType.type);			}						//////trace("oPowerUpType.length=" + oPowerUpType.length);			//trace("oPowerUpType[1].playerInvincibleAdjust=" + oPowerUpType[1].playerInvincibleAdjust);		//////trace("done creating enemy types");						}						public function playGetReady() {			if (!getReadyScreen.getstarted()) {				//////trace("first get ready pass");				getReadyScreen.start();				getReadyScreen.addEventListener(GetReadyScreen.COMPLETE, getReadyCompleteListener,false,0,true);			}			dispatchEvent(new Event(GETREADYUPDATE));			}								public function getReadyCompleteListener(e:Event) {			getReadyScreen.removeEventListener(GetReadyScreen.COMPLETE, getReadyCompleteListener);			currentPlayState=STATE_PLAY_PLAYERSTART;		}				public function playPlayerStart():void {			//reset attackbonus			killBonusCount=0;			attackBonusPerKill=int(levelData.attackbonusperkill);			player.setplayerStartRow(int(levelData.playerstartrow));			player.setplayerStartCol(int(levelData.playerstartcol));			player.addEventListener(INCREMENTBONUSX, playerbonusupdateListener,false,0,true);			dispatchEvent(new Event(PLAYERSTART));			currentPlayState=STATE_PLAY_GAMERUN;								}					function playGameRun() {			//////trace("in game run");			//////trace("playing the game");			checkForEndofLevel();			checkInput();		//	////trace("checkInput complete");			updateObjectsInMemory();			//////trace("update objects in menory complete");			enumerateEffects(); // loop through exposions, messages, scoring. Splice them if necessary			//////trace("enumerate effects complete");			checkCollisions();			//////trace("check collisions complete");			renderScreen();			//////trace("render complete");						if (princessWaitStarted) {				princessCount++;				if (princessCount>princessWait){					dispatchEvent(new Event(POWERUPPRINCESSPLAYSOUND));					princessWaitStarted=false;					princessCount=0;				}			}										}			public function playPlayerDie() {			if (!player.deathStarted) {				player.removeEventListener(INCREMENTBONUSX, playerbonusupdateListener);				dispatchEvent(new Event(PLAYERDEATHSTARTED));				for (var eCtr=aEnemy.length-1;eCtr>=0;eCtr--) {					aEnemy[eCtr].removeMe();					aEnemy[eCtr]=null;					aEnemy.splice(eCtr,1);				}			//////trace("aEnemy.length=" + aEnemy.length);			}					if (player.deathComplete) {				//////trace("in player.deathComplete");								dispatchEvent(new Event(PLAYERDEATHCOMPLETE));				if (player.lives == 0) {					currentState=STATE_LEVEL_GAME_OVER;					currentPlayState=STATE_PLAY_GETREADY;				}else{					createEnemyForLevel();					currentPlayState=STATE_PLAY_GETREADY;				}							}else{				//////trace("rendering death");								renderScreen();				//player.playerDeathUpdate();			}			}			public function checkInput() {			player.checkInput();		}				function updateObjectsInMemory() {			dispatchEvent(new Event(UPDATE));		 		}				function enumerateEffects(){			// loop through exlposions, messages, scoring. Splice them if necessary			explodeLength=aExplode.length-1;			var eCtr:int; // explode counter			for (eCtr=explodeLength;eCtr>=0;eCtr--) {				tempExplode=aExplode[eCtr];				if (tempExplode.complete) {					tempExplode.removeMe();					aExplode.splice(eCtr,1);				}			}						messageLength=aMessage.length-1;			//var tempMessage:InPlayMessage;			for (eCtr2=messageLength;eCtr2>=0;eCtr2--) {				//tempMessage=aMessage[eCtr2];				if (aMessage[eCtr2].complete) {					aMessage[eCtr2].removeMe();					aMessage.splice(eCtr2,1);				}			}					}				public function renderScreen():void {			//gameScreenBitmapData.lock();			//gameScreenBitmapDataDisplay.lock();			//////trace("in render");			copyBackgroundToScreen();			//////trace("after copyBackgroundToScreen();");			copyTilemapToScreen();			//////trace("after copyTilemapToScreen();");			dispatchEvent(new Event(RENDER));			//////trace("after dispatchEvent(new Event(RENDER));");			//copyBufferToDisplay();			//gameScreenBitmapData.unlock();			//gameScreenBitmapDataDisplay.unlock();														}				function copyBufferToDisplay():void {			//*** the final double buffer ***						//gameScreenBitmapDataDisplay.copyPixels(gameScreenBitmapData,screenRectangle, screenTopPoint);		}						function checkCollisions():void {			dispatchEvent(new Event(CHECK_WALL_COLLISIONS));							hitx=player.centernextx + (player.hitx*.5*tileSize);			hity=player.centernexty + (player.hity*.5*tileSize);						player.hittilerow=int(hity / tileSize);			player.hittilecol=int(hitx / tileSize);			// if tunnel, check tile on other side, not the empty tile			if (player.hittilerow > mapRows-1) player.hittilerow=0;			if (player.hittilerow < 0) player.hittilerow=mapRows-1;			if (player.hittilecol > mapCols-1) player.hittilecol=0;			if (player.hittilecol < 0) player.hittilecol=mapCols-1;						var hitMiddleX:int = (player.hittilecol * tileSize)+(tileSize*.5);			var hitMiddleY:int= (player.hittilerow * tileSize)+(tileSize*.5);						try{				var nextHitTile:Tile=aTileMap[player.hittilerow][player.hittilecol];			}catch (error:Error){				////////trace("*** checkCollisions error ***");				////////trace("*** <Error> " + error.message);				////////trace("*** player.hittilecol=" + player.hittilecol);				////////trace("*** player.hittilerow=" + player.hittilerow);							}			if (!nextHitTile.isWalkable) {				//////////trace("hit wall");								if (player.moveRight) {					var difference:Number=(player.hittilecol*tileSize)-player.centernextx;					//////trace("difference in x=" + difference.toString());					//////trace("player.nextx=" + player.nextx);					if (difference >= .4*tileSize) {						player.setnextx(player.x+1);					}else{						player.setnextx(player.x);					}														}								if (player.moveLeft) {					difference=player.centernextx-(player.hittilecol*tileSize+tileSize);					//////trace("difference in x=" + difference.toString());					//////trace("player.nextx=" + player.nextx);					if (difference >= .4*tileSize) {						player.setnextx(player.x-1);					}else{						player.setnextx(player.x);					}				}								if (player.moveDown) {					difference=(player.hittilerow*tileSize)-player.centernexty;					//////trace("difference in y=" + difference.toString());					if (difference >= .4*tileSize) {						player.setnexty(player.y+1);					}else{						player.setnexty(player.y);					}														}				if (player.moveUp) {					difference=player.centernexty-(player.hittilerow*tileSize+tileSize);					//////trace("difference in y=" + difference.toString());					if (difference >= .4*tileSize) {						player.setnexty(player.y-1);					}else{						player.setnexty(player.y);					}				}			}else if (nextHitTile.isTransport && !player.transportStarted) {				trace("transporter");								//randomly select reveivers until a tid is a match. Change player's x and y position				if (player.centernexty>=hitMiddleY-hitTransThreshold && player.centernexty<=hitMiddleY+hitTransThreshold && player.centernextx>=hitMiddleX-hitTransThreshold && player.centernextx<=hitMiddleX+hitTransThreshold) {															rFound=false;					while (!rFound) {						randReceiver = int(Math.random()*aReceiver.length);						tempTile=aReceiver[randReceiver];						if (tempTile.transportID == nextHitTile.transportID) {																					rFound=true;							player.setNextTransportLocation(tempTile.destX,tempTile.destY);							//player.setnexty(tempTile.destY);							//player.setnextx(tempTile.destX);							dispatchEvent(new Event(TRANSPORTSTART));						}					}				}				//////////trace("hit wall");			}else if (nextHitTile.isCollectible) {				//check to see is player hits middle of tile				//////trace("collectible");												//////////trace("hitMiddleX:"+hitMiddleX + " player.nextx:" + player.nextx);				//////////trace("hitMiddleY:"+hitMiddleY + " player.nexty:" + player.nexty);								if (player.centernexty>=hitMiddleY-dotEatThreshold && player.centernexty<=hitMiddleY+dotEatThreshold && player.centernextx>=hitMiddleX-dotEatThreshold && player.centernextx<=hitMiddleX+dotEatThreshold) {					//gameLoop.soundManager.playEatDot();					dispatchEvent(new Event(PLAYEREATDOT));				//**** Example of using pixel level detection on bitmap in each tile				//var tileLeftCornerPoint:Point=new Point(player.hittilecol * tileSize,player.hittilerow * tileSize);				//var playerLeftCornerPoint:Point=new Point(player.nextx, player.nexty);				////////trace("tileLeftCornerPoint=" + tileLeftCornerPoint);				////////trace("playerLeftCornerPoint" + playerLeftCornerPoint);				//if (player.getCurrentBitmapData().hitTest(playerLeftCornerPoint,255,nextHitTile.getCurrentBitmapData(),tileLeftCornerPoint)){				// End **** Example of using pixel level detection on bitmap in each tile					//trace("eat");					thisTile=aTileMap[player.hittilerow][player.hittilecol];					dotEatenCount++;					//trace("1")															if (thisTile.isPowerUp) {						//gameLoop.soundManager.playEatPowerup();						dispatchEvent(new Event(PLAYEREATPOWERUP));						//trace("this is a powerUp");						//trace("powerUpType=" + thisTile.powerUpType);						//trace("oPowerUpType[thisTile.powerUpType].type=" + oPowerUpType[thisTile.powerUpType].type);										//trace("playerAccAdjust=" + oPowerUpType[thisTile.powerUpType].playerAccAdjust);						//trace("playerAccTimeAdd=" + oPowerUpType[thisTile.powerUpType].playerAccTimeAdd);						//trace("playerInvincibleAdjust=" + oPowerUpType[thisTile.powerUpType].playerInvincibleAdjust);						//trace("playerInvincibleTimeAdd=" + oPowerUpType[thisTile.powerUpType].playerInvincibleTimeAdd);						//trace("playerEatEnemyAdjust=" + oPowerUpType[thisTile.powerUpType].playerEatEnemyAdjust);						//trace("playerEatEnemyTimeAdd=" + oPowerUpType[thisTile.powerUpType].playerEatEnemyTimeAdd);						//trace("playerScoreAdjust=" + oPowerUpType[thisTile.powerUpType].playerScoreAdjust);						//trace("playerBonusAdjust=" + oPowerUpType[thisTile.powerUpType].playerBonusAdjust);						//trace("playerBonusTimeAdjust=" + oPowerUpType[thisTile.powerUpType].playerBonusTimeAdjust);												player.incrementscore(oPowerUpType[thisTile.powerUpType].playerScoreAdjust);						scorePanel.updateScore(player.getscore());						player.incrementAttackBonus(oPowerUpType[thisTile.powerUpType].playerBonusAdjust);;						if (oPowerUpType[thisTile.powerUpType].playerEatEnemyAdjust) {							//trace("ATTACK!");							attackTimeToAdd=oPowerUpType[thisTile.powerUpType].playerEatEnemyTimeAdd * 1000;							//trace("going to add " + oPowerUpType[thisTile.powerUpType].playerEatEnemyTimeAdd + " seconds to attack .");							scorePanel.attackTimerStart(attackTimeToAdd);						}						if (oPowerUpType[thisTile.powerUpType].playerInvincibleAdjust) {							//trace("INVINCIBLE!");							invincbibleTimeToAdd=oPowerUpType[thisTile.powerUpType].playerInvincibleTimeAdd * 1000;							//trace("going to add " + oPowerUpType[thisTile.powerUpType].playerInvincibleTimeAdd + " seconds to invincible .");							scorePanel.invTimeIncrement(invincbibleTimeToAdd);							dispatchEvent(new Event(INVTIMERSTART));																				}												if (oPowerUpType[thisTile.powerUpType].playerAccAdjust >0) {							trace("Freeze!");							//player.accAdjust=oPowerUpType[thisTile.powerUpType].playerAccAdjust;							accTimeToAdd=oPowerUpType[thisTile.powerUpType].playerAccTimeAdd * 1000;							//trace("going to add " + oPowerUpType[thisTile.powerUpType].playerInvincibleTimeAdd + " seconds to invincible .");							scorePanel.accTimeIncrement(accTimeToAdd);							dispatchEvent(new Event(ACCTIMERSTART));						}																								if (oPowerUpType[thisTile.powerUpType].playerBonusXAdjust >0) {							//lightening power up adds amount needs for bounxupdate * the playerBonusXAdjust							player.incrementattackBonusCount(enemyToEatForBonusXPlus * oPowerUpType[thisTile.powerUpType].playerBonusXAdjust);							trace("** bonusx + = " + enemyToEatForBonusXPlus * oPowerUpType[thisTile.powerUpType].playerBonusXAdjust)						}																		if (oPowerUpType[thisTile.powerUpType].playerBonusAdjust > 0) {							createInPlayMessage(player.x, player.y+20,"bonus", String(oPowerUpType[thisTile.powerUpType].playerBonusAdjust));						}												if (oPowerUpType[thisTile.powerUpType].playerKillAllEnemyAdjust) {							trace("kill all enemy");							killAllEnemy();							dispatchEvent(new Event(POWERUPKILLALL));						}												if (oPowerUpType[thisTile.powerUpType].title=="princess") {							trace("princess");							dispatchEvent(new Event(POWERUPPRINCESS));							princessWaitStarted=true;							}																	}else if (thisTile.isKey){						if (thisTile.isKey) {							trace("key eaten");							dispatchEvent(new Event(KEYEATEN));						}					}else{						//trace("adding to player score");						player.incrementscore(dotScore);;						//trace("2")						scorePanel.updateScore(player.getscore());						//trace("3")					}										//1. check to see if player is close to center of tile					//***need a function to turn a tile into a plain walkway***					changeTile(thisTile, erasertile);					thisTile.isCollectible = false;					thisTile.animate = false;					destY=player.hittilerow*tileSize;					destX=player.hittilecol*tileSize;				}							}			 			//check for player collisions with enemy			enemyLength= aEnemy.length;			for (enemyCounter=enemyLength-1;enemyCounter >=0;enemyCounter--) {				tempEnemy=aEnemy[enemyCounter];				if (player.centernexty>=tempEnemy.centery-enemyHitThreshold && player.centernexty<=tempEnemy.centery+enemyHitThreshold && player.centernextx>=tempEnemy.centerx-enemyHitThreshold && player.centernextx<=tempEnemy.centerx+enemyHitThreshold) {										if (tempEnemy.aiState==AI_STATE_FLEE) {						killAnEnemy(tempEnemy);					}else if (!player.invincible && !player.transportStarted ){						//gameLoop.soundManager.playPlayerDie()						dispatchEvent(new Event(PLAYERDIE));						currentPlayState=STATE_PLAY_PLAYERDIE;						killBonusCount=0;					}				}			}								}						public function createExplode(xval:int, yval:int) {			tempExplode=new Explode(xval,yval,"EnemyEat",2,this);			tempExplode.startMe();			aExplode.push(tempExplode);					}				public function changeTile(tileval:Tile,sheetNum:int) {			//////trace("sheetNum=" + sheetNum);			sheetTile=aTilesheetData[sheetNum];			tempTile=tileval;			tempTile.dispose();			tempTile.aTileBitmapData=sheetTile.aTileBitmapData;			tempTile.isWalkable=sheetTile.isWalkable;			tempTile.isCollectible=sheetTile.isCollectible;			tempTile.isPowerUp=sheetTile.isPowerUp;			tempTile.powerUpType=sheetTile.powerUpType;			tempTile.animate=sheetTile.animate;			tempTile.tileSize=sheetTile.tileSize;			tempTile.animationFrameDelay=sheetTile.animationFrameDelay			tempTile.tileBitmapDataIndex=0;		}								//listeners		function keyDownListener(e:KeyboardEvent):void {						if (e.keyCode==77) {				trace("M pressed in level out");				gameLoop.dispatchSoundMuteEvent();			}						switch (currentPlayState) {				case STATE_PLAY_GAMERUN:					if (e.keyCode==112 || e.keyCode==80) {						previousStateBeforePause=currentPlayState;						currentPlayState=STATE_PLAY_PAUSED;					}else{						player.detectKeyPress(e.keyCode);					}					break;				case STATE_PLAY_PAUSED:					pausedScreen.detectKeyPress(e.keyCode);					break;			}					}				public function playPlayerOut() {			//trace("gamePlay playerOut function");			if (!player.leveloutStarted) {				dispatchEvent(new Event(PLAYEROUTSTARTED));											player.startLevelout();							//trace(" before removeMe aEnemy.length=" + aEnemy.length);				for (eCtr=aEnemy.length-1;eCtr>=0;eCtr--) {				aEnemy[eCtr].removeMe();				aEnemy[eCtr]=null;				aEnemy.splice(eCtr,1);				}				//trace("after RemoveMe aEnemy.length=" + aEnemy.length);			}					if (player.leveloutComplete) {				//trace("in player.levelOut complete");				currentState=STATE_LEVEL_OUT;											}else{				//trace("gamePlay rendering levelOut");				player.playerLevelOutUpdate();				renderScreen();			}					}			public function levelOut() {			//////trace("levelOut function");			if (!levelOutScreen.getstarted()) {				levelOutScreen.start();				levelOutScreen.addEventListener(LevelOutScreen.COMPLETE, levelOutCompleteListener,false,0,true);				disposeObjectsEndlevel();			}			dispatchEvent(new Event(LEVELOUTUPDATE));				if (gameScreenBitmap.y >-480) {				gameScreenBitmap.y-=10;			}		}				public function levelOutCompleteListener(e:Event) {			levelOutScreen.removeEventListener(LevelOutScreen.COMPLETE, levelOutCompleteListener);			level++;			if (level > numLevels) {				level=1;				levelspeedadjust+=1;				if (levelspeedadjust >INSANE) {					levelspeedadjust=INSANE;				}								currentState=STATE_LOAD_LEVEL_DATA;				currentPlayState=STATE_PLAY_GETREADY;			}else{				currentState=STATE_LOAD_LEVEL_DATA;				currentPlayState=STATE_PLAY_GETREADY;			}		}								public function checkForEndofLevel():void {			if (dotEatenCount == dotTotalCount) {				//traces("all dots eaten!");				currentPlayState=STATE_PLAY_PLAYEROUT;			}					}				public function gameWon() {			trace("game won!");			gameLoop.systemState=GameLoop.STATE_SYSTEM_GAMEWON;			trace("game won 1");			gameLoop.setlastScore(player.getscore());			trace("game won 2");			gameLoop.setlastLives(player.getlives());			trace("game won 3");			gameLoop.setlastLevel(level);			//gameLoop.removeChild(scorePanel);			gameLoop.removeChild(gameScreenBitmap);			trace("game won 4");			disposeObjectsWinGame();			trace("game won 5");			if (levelOutScreen.getstarted()) {				levelOutScreen.removeFromScreen();			}			trace("game won 6");		}				public function gameOver() {			if (!gameOverScreen.getstarted()) {				trace("game over start");				gameOverScreen.start();				gameOverScreen.addEventListener(GameOverScreen.COMPLETE, gameOverCompleteListener,false,0,true);			}			trace("game over");			dispatchEvent(new Event(GAMEOVERUPDATE));			}				public function gameOverCompleteListener(e:Event) {			trace("game over complete listener");			gameOverScreen.removeEventListener(GameOverScreen.COMPLETE, gameOverCompleteListener);			gameLoop.systemState=GameLoop.STATE_SYSTEM_GAMEOVER;			gameLoop.setlastScore(player.getscore());			gameLoop.setlastLevel(level);			gameLoop.setlast_levelspeedadjust(levelspeedadjust);			//gameLoop.removeChild(scorePanel);			gameLoop.removeChild(gameScreenBitmap);			disposeObjectsEndOfGame();			if (levelOutScreen.getstarted()) {				levelOutScreen.removeFromScreen();			}		}				public function playPaused():void {			if (!pausedScreen.started) {				dispatchEvent(new Event(PAUSEDSTARTED));				pausedScreen.start();				pausedScreen.addEventListener(PausedScreen.COMPLETE, pausedScreenCompleteListener,false,0,true);				pausedScreen.addEventListener(PausedScreen.QUIT, pausedScreenQuitListener,false,0,true);			}		}			public function pausedScreenCompleteListener(e:Event):void {			pausedScreen.removeEventListener(PausedScreen.COMPLETE, pausedScreenCompleteListener);			pausedScreen.removeEventListener(PausedScreen.QUIT, pausedScreenQuitListener);			currentPlayState=STATE_PLAY_GAMERUN;			pausedScreen.started=false;		}				public function pausedScreenQuitListener(e:Event):void {			pausedScreen.removeEventListener(PausedScreen.COMPLETE, pausedScreenCompleteListener);			pausedScreen.removeEventListener(PausedScreen.QUIT, pausedScreenQuitListener);			dispatchEvent(new Event(GAMEQUIT));			currentPlayState=STATE_PLAY_PLAYEROUT			currentState=STATE_LEVEL_GAME_OVER			pausedScreen.started=false;		}				public function createInPlayMessage(xval:int, yval:int,type:String, messageText:String){			message=new InPlayMessage(xval,yval,type,messageText,this);			aMessage.push(message);		}										public function killAllEnemy():void {						for (eCtr=aEnemy.length-1;eCtr>=0;eCtr--) {				tempEnemy=aEnemy[eCtr];				killAnEnemy(tempEnemy);				}		}				public function killAnEnemy(tempEnemy:Enemy):void {			player.incrementscore(tempEnemy.score);			killBonusCount++;			attackBonus=attackBonusPerKill + (killBonusMultiplier*killBonusCount);			player.incrementAttackBonus(attackBonus);			createInPlayMessage(tempEnemy.x, tempEnemy.y+20,"bonus", String(attackBonus));			player.incrementattackBonusCount(1);			scorePanel.updateScore(player.getscore());			createExplode(tempEnemy.x,tempEnemy.y);			tempEnemy.eatMe();			dispatchEvent(new Event(PLAYEREATENEMY));					}				public function playerbonusupdateListener(e:Event):void {			trace("gamePlay playerbonusupdateListener");			createInPlayMessage(player.x, player.y,"bonusx", "Bonus X Increase!");		}				function disposeObjectsEndlevel():void{						//var levelString:String="Level"+level+"DataXML";			//this[levelString]=null;						levelData=null;			trace("1");					for (ctr1=0; ctr1 <aTileMap.length;ctr1++){				for (ctr2=0; ctr2 <aTileMap[ctr1].length;ctr2++){					aTileMap[ctr1][ctr2].dispose();					aTileMap[ctr1][ctr2]=null;				}			}			aTileMap=null;			trace("2");			for (ctr1=0;ctr1<aAnimatedTile.length;ctr1++) {				aAnimatedTile[ctr1]=null;			}			aAnimatedTile=null;			trace("3");			for (ctr1=0;ctr1<aEnemyGenerator.length;ctr1++) {				aEnemyGenerator[ctr1]=null;			}			aEnemyGenerator=null;			trace("4");			for (ctr1=0;ctr1<aTransport.length;ctr1++) {				aTransport[ctr1]=null;			}			aTransport=null;			trace("5");			for (ctr1=0;ctr1<aReceiver.length;ctr1++) {				aReceiver[ctr1]=null;			}			aReceiver=null;			trace("6");			//enemy			/*			for (ctr1=0;ctr1<aEnemyType.length;ctr1++) {				aEnemyType[ctr1].dispose();				aEnemyType[ctr1]=null;			}			aEnemy=null;			trace("7");			*/					}								public function disposeObjectsEndOfGame() {			player.dispose();			player=null;			levelData=null;			level1DataXML=null;			level2DataXML=null;			level3DataXML=null;						gameDataXML=null;			gameXML=null;						trace("dispose 1");									for (ctr1=0; ctr1 <aTileMap.length;ctr1++){				trace("dispose 1.1");				for (ctr2=0; ctr2 <aTileMap[ctr1].length;ctr2++){					trace("dispose 1.2");					aTileMap[ctr1][ctr2].dispose();					trace("dispose 1.3");					aTileMap[ctr1][ctr2]=null;					trace("dispose 1.4");				}			}			trace("dispose 2");			aTileMap=null;			tileSheet.dispose();			tileSheet=null;			tilesheetBitmapData=null			aTilesheetData=null;			trace("dispose 3");			for (ctr1=0;ctr1<aAnimatedTile.length;ctr1++) {				aAnimatedTile[ctr1]=null;			}			aAnimatedTile=null;			trace("dispose 4");			//level in			levelInScreen=null;			trace("dispose 5");			//level in			trace("dispose 6");			getReadyScreen=null;			trace("dispose 7");			//gameOver			gameOverScreen=null;			trace("dispose 8");			for (ctr1=0;ctr1<aEnemyGenerator.length;ctr1++) {				aEnemyGenerator[ctr1]=null;			}			aEnemyGenerator=null;			trace("dispose 9");			for (ctr1=0;ctr1<aTransport.length;ctr1++) {				aTransport[ctr1]=null;			}			aTransport=null;			trace("dispose 10");			for (ctr1=0;ctr1<aReceiver.length;ctr1++) {				aReceiver[ctr1]=null;			}			aReceiver=null;			trace("dispose 11");			//background 			backgroundBitmapData=null;			trace("dispose 12");			//gamescreen			gameScreenBitmap=null;			gameScreenBitmapData=null;			//gameScreenBitmapDataDisplay=null;			trace("dispose 13");			//powerups			oPowerUpType=null;			trace("dispose 14");			//scorepanel			scorePanel=null;			trace("dispose 15");			//explosions			oExplodeType=null;			aExplode=null;			trace("dispose 16");			//InPlayMessages			aMessage=null;			trace("dispose 17");			gameMessageManager=null;			trace("dispose 18");			//transports and receivers			oReceiverType=null;			trace("dispose 19");			//enemy			for (ctr1=0;ctr1<aEnemy.length;ctr1++) {				aEnemy[ctr1].dispose();				aEnemy[ctr1]=null;			}			aEnemy=null;			trace("dispose 20");			for (ctr1=0;ctr1<aEnemyType.length;ctr1++) {				aEnemyType[ctr1].dispose();				aEnemyType[ctr1]=null;			}			trace("dispose 21");			aEnemyType=null;			trace("dispose 22");														}				public function disposeObjectsWinGame() {			player.dispose();			player=null;			levelData=null;			level1DataXML=null;			level2DataXML=null;			level3DataXML=null;						gameDataXML=null;			gameXML=null;						trace("dispose 1");												tileSheet.dispose();			tileSheet=null;			tilesheetBitmapData=null			aTilesheetData=null;			trace("dispose 3");								//level in			levelInScreen=null;			trace("dispose 5");			//level in			trace("dispose 6");			getReadyScreen=null;			trace("dispose 7");			//gameOver			gameOverScreen=null;			trace("dispose 8");									//background 			backgroundBitmapData=null;			trace("dispose 12");			//gamescreen			gameScreenBitmap=null;			gameScreenBitmapData=null;			//gameScreenBitmapDataDisplay=null;			trace("dispose 13");			//powerups			oPowerUpType=null;			trace("dispose 14");			//scorepanel			scorePanel=null;			trace("dispose 15");			//explosions			oExplodeType=null;			aExplode=null;			trace("dispose 16");			//InPlayMessages			aMessage=null;			trace("dispose 17");			gameMessageManager=null;			trace("dispose 18");			//transports and receivers			oReceiverType=null;			trace("dispose 19");			//enemy			for (ctr1=0;ctr1<aEnemy.length;ctr1++) {				aEnemy[ctr1].dispose();				aEnemy[ctr1]=null;			}			aEnemy=null;			trace("dispose 20");			for (ctr1=0;ctr1<aEnemyType.length;ctr1++) {				aEnemyType[ctr1].dispose();				aEnemyType[ctr1]=null;			}			trace("dispose 21");			aEnemyType=null;			trace("dispose 22");														}			} // end class} // end package