/*** ...* @author Default* @version 0.1*/package {	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.filters.GlowFilter;	import flash.geom.*;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.events.*;	import GamePlay;		public class InPlayMessage {				private var messageText:String;		private var messageBitmapData:BitmapData;		private var lifeSpan:int=0;		private var lifeCount:int=0;		private var messageTextField:TextField = new TextField();		private var gamePlay:GamePlay;		public var started:Boolean=false;		public var complete:Boolean=false;		private var format:TextFormat=new TextFormat();		private var type:String;		private var x:int;		private var y:int;		private var glowfilter=new GlowFilter();		private var applyGlowFilter:Boolean=false;		private var glowFilterrect:Rectangle;		private var applyAlpha:Boolean=false;		private var alpha:Number=1;		private var alphaSubtract:Number=.01;		private var fontType:Boolean=false;		private var holder_mc:MovieClip=new MovieClip();		private var mcHeightBuffer:int=10;		private var scale:Number=1;		private var renderPoint:Point=new Point();		private var renderRect:Rectangle;		private var cTransform:ColorTransform = new ColorTransform();		private var cTransrect:Rectangle;				public function InPlayMessage(xval:int, yval:int,typeVal:String, textVal:String, gp:GamePlay){			trace("inplay 1")			messageText=textVal;			gamePlay=gp;			type=typeVal;			x=xval;			y=yval;			trace("inplay 2")			renderPoint.x=x;			renderPoint.y=y;			trace("inplay 3")			selectType();			cacheToBitmapData();			startMe();					}			private function selectType() {			var finalMessage:String;			switch (type) {								case "score": 					fontType=true;					finalMessage ="score + " + messageText;					format.size=12;					format.font="Arial";					format.color="0xffffff";					format.bold=true;					messageTextField.text=finalMessage					messageTextField.setTextFormat(format);					messageTextField.width=(finalMessage.length+2)*int(format.size);					messageTextField.height=int(format.size)*2;					lifeSpan=60;					applyAlpha=false;					applyGlowFilter=false;					alphaSubtract=.01;					mcHeightBuffer=0;					break;				case "bonus": 					fontType=true;					finalMessage ="bonus + " + messageText;					format.size=12;					format.font="Arial";					format.color="0xffffff";					format.bold=true;					messageTextField.text=finalMessage					messageTextField.setTextFormat(format);					messageTextField.width=(finalMessage.length+2)*int(format.size);					messageTextField.height=int(format.size)*2;					lifeSpan=60;					glowfilter=new GlowFilter(0x000000, 1,  3,  3,  2, 2, false, false);					applyGlowFilter=true;					applyAlpha=false;					alphaSubtract=.01;					mcHeightBuffer=0;					break;								case "bonusx": 					fontType=true;					y-=20;					finalMessage =messageText;					format.size=12;					format.font="Arial";					format.color="0xffffff";					format.bold=true;					messageTextField.text=finalMessage					messageTextField.setTextFormat(format);					messageTextField.width=(finalMessage.length+2)*int(format.size);					messageTextField.height=int(format.size)*2;					lifeSpan=60;					//glowfilter=new GlowFilter(0x000000, 1,  3,  3,  2, 2, false, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.01;					mcHeightBuffer=0;					break;				case "BigGO" :					//1. create a instance of the messageClip to hold the message.										fontType=false;					lifeSpan=100;										scale=1;					holder_mc=new arcadego();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//holder_mc.holder.rotation=180;					//glowfilter=new GlowFilter(0x00ff00, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;				case "BigAttack" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadeattack();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0xff0000, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;									case "BigFreeze" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadefreeze();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0x0000ff, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;										case "BigBonusX" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadebonusxup();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0x00ff00, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;										case "BigProtect" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadeprotect();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0xFFFF00, .5,  4,  4,  2, 7, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;									case "BigKill" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadekill();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0x0000ff, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;										case "BigKey" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadekey();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0xFF9900, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;										case "BigTransport" :					//1. create a instance of the messageClip to hold the message.					fontType=false;					lifeSpan=400;					scale=1;					holder_mc=new arcadetransport();					//holder_mc.holder.scaleX=scale;					//holder_mc.holder.scaleY=scale;					//glowfilter=new GlowFilter(0x00ff00, .5,  4,  4,  2, 5, true, false);					//applyGlowFilter=true;					applyAlpha=true;					alphaSubtract=.001;					mcHeightBuffer=10;					break;																								}				if (fontType) {					cTransrect= new Rectangle(0, 0, messageTextField.width, messageTextField.height);					renderRect=new Rectangle(0,0,messageTextField.width,messageTextField.height);				}else{					cTransrect= new Rectangle(0, 0, int(holder_mc.width),int(holder_mc.height+mcHeightBuffer));					renderRect=new Rectangle(0,0,int(holder_mc.width),int(holder_mc.height+mcHeightBuffer));				}				trace("inplay 4")		}				private function cacheToBitmapData():void {						if (fontType) {				messageBitmapData=new BitmapData(messageTextField.width,messageTextField.height,true,0x00000000);				messageBitmapData.draw(messageTextField);							if (applyGlowFilter) {					glowFilterrect=new Rectangle(0, 0, messageTextField.width, messageTextField.height);					messageBitmapData.applyFilter(messageBitmapData,glowFilterrect,new Point(0,0),glowfilter);				}			}else{				//for the custom build text				//trace("holder_mc.width=" + int(holder_mc.width));				messageBitmapData=new BitmapData(int(holder_mc.width),int(holder_mc.height+mcHeightBuffer),true,0x00000000);				messageBitmapData.draw(holder_mc);							if (applyGlowFilter) {					glowFilterrect=new Rectangle(0, 0, int(holder_mc.width), int(holder_mc.height+mcHeightBuffer));					messageBitmapData.applyFilter(messageBitmapData,glowFilterrect,new Point(0,0),glowfilter);				}			}		}				public function startMe() {			started=true;			gamePlay.addEventListener(GamePlay.RENDER, renderListener,false,0,true);		}				public function removeMe(){			gamePlay.removeEventListener(GamePlay.RENDER, renderListener);			messageBitmapData.dispose();			messageBitmapData=null;			messageText=null;			messageTextField=null;			format=null;			type=null;			glowfilter=null;			holder_mc=null;			renderRect=null;			cTransform=null;			cTransrect=null;			complete=true; 					}				private function renderListener (e:Event):void {			if (started) {				render();			}		}				public function render() {			if (applyAlpha) {												if (fontType) {					cTransrect= new Rectangle(0, 0, messageTextField.width, messageTextField.height);				}else{					cTransrect= new Rectangle(0, 0, int(holder_mc.width),int(holder_mc.height+mcHeightBuffer));				}								cTransform.alphaMultiplier=alpha;				messageBitmapData.colorTransform(cTransrect, cTransform);				alpha-=alphaSubtract;			}									if (fontType) {								gamePlay.getgameScreenBitmapData().copyPixels(messageBitmapData,renderRect, renderPoint);			}else{								gamePlay.getgameScreenBitmapData().copyPixels(messageBitmapData,renderRect, renderPoint);			}						lifeCount++;			if (lifeCount > lifeSpan) {				complete=true;				started=false;			}		}	}	}